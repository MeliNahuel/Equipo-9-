clase 1


public static void main(String[] args) {
    int[][] mat = {
            {4, 5, 6},
            {7, 8, 9},
            {5, 6, 7}
    };

    int suma = 0;
    int n = mat.length; // Suponiendo que la matriz es cuadrada, n será tanto el número de filas como de columnas

    // Sumar todos los elementos de la matriz
    for (int i = 0; i < n; i++) {                  // Instrucción 1
        for (int j = 0; j < n; j++) {              // Instrucción 2
            suma += mat[i][j];                     // Instrucción 3
        }
    }

    // Calcular el número total de elementos
    int totalElementos = n * n;                    // Instrucción 4

    // Calcular el promedio
    double promedio = (double) suma / totalElementos; // Instrucción 5

    // Imprimir el promedio
    System.out.println("El promedio de los elementos de la matriz es: " + promedio); // Instrucción 6
}
------------------------------------------------------------------------------------------------------------------------------------------------

Actividad 1.1
public class MaximoArray {
    public static int encontrarMaximo(int[] array) {
        int max = array[0];
        for (int i = 1; i < array.length; i++) {
            if (array[i] > max) {
                max = array[i];
            }
        }
      return max;
    }
    public static void main(String[] args) {
        int[] numeros = {4, 7, 1, 9, 3};
        int maximo = encontrarMaximo(numeros);
        System.out.println("El Maximo es: " + maximo);
    }
}


/// Orden de complejidad asintótica:
//La complejidad asintótica del programa es ( O(n) ), donde ( n ) es el número de elementos en el array.
// Esto se debe a que el algoritmo debe recorrer todos los elementos del array una vez para encontrar el máximo.


public class FacturaciónSinMap {
    public static void main(String[] args) {
        int[][] facturas = {
                {1, 1, 100},
                {2, 2, 200},
                {3, 1, 150}
        };

        String[][] clientes = {
                {"1", "Cliente1"},
                {"2", "Cliente2"},
        };

        for (String[] cliente : clientes) {
            int idCliente = Integer.parseInt(cliente[0]);
            String nombreCliente = cliente[1];
            int sumaImportes = 0;

            for (int[] factura : facturas) {
                if (factura[1] == idCliente) {
                    sumaImportes += factura[2];
                }
            }

            System.out.println("ID Cliente: " + idCliente + ", Nombre: " + nombreCliente + ", Suma Importes: " + sumaImportes);
        }
    }
}

/// Diferencia en cuanto a la complejidad asintótica:
// Sin Map: La complejidad es ( O(n \times m) ), donde ( n ) es el número de clientes y ( m ) es el número de facturas. Esto se debe a que, para cada cliente, se recorre la lista completa de facturas.
// Con Map: La complejidad es ( O(n + m) ). Primero se recorre la lista de facturas una vez para sumar los importes por cliente (( O(m) )), y luego se recorre la lista de clientes para imprimir los resultados (( O(n) )).
// Esto es más eficiente que la implementación sin Map.


import java.util.HashMap;
import java.util.Map;

public class FacturaciónConMap {
    public static void main(String[] args) {
        int[][] facturas = {
                {1, 1, 100},
                {2, 2, 200},
                {3, 1, 150}
        };

        Map<Integer, String> clientes = new HashMap<>();
        clientes.put(1, "Cliente1");
        clientes.put(2, "Cliente2");

        Map<Integer, Integer> sumaImportesPorCliente = new HashMap<>();

        for (int[] factura : facturas) {
            int idCliente = factura[1];
            int importe = factura[2];

            sumaImportesPorCliente.put(idCliente, sumaImportesPorCliente.getOrDefault(idCliente, 0) + importe);
        }

        for (Map.Entry<Integer, Integer> entrada : sumaImportesPorCliente.entrySet()) {
            int idCliente = entrada.getKey();
            int sumaImportes = entrada.getValue();
            String nombreCliente = clientes.get(idCliente);

            System.out.println("ID Cliente: " + idCliente + ", Nombre: " + nombreCliente + ", Suma Importes: " + sumaImportes);
        }
    }
}

---------------------------------------------------------------------------------------------------------------------

Actividad 1.2



import java.math.BigInteger;

public class LongAndBigIntegerExample {
    public static void main(String[] args) {
        // Example using long
        long a = 9223372036854775807L; // Maximum value of long
        long b = 1L;
        long resultLong = a + b; // This will cause an overflow

        System.out.println("Result using long (with overflow): " + resultLong);

        // Example using BigInteger
        BigInteger bigA = new BigInteger("9223372036854775807");
        BigInteger bigB = new BigInteger("1");
        BigInteger resultBigInteger = bigA.add(bigB); // No overflow here

        System.out.println("Result using BigInteger: " + resultBigInteger);
    }
}

/// Tipo de Dato longEl tipo de dato long en Java es un entero con complemento a dos de 64 bits. 
Tiene un valor mínimo de -2^63 y un valor máximo de 2^63-1. 
Se usa cuando necesitas un rango de valores más amplio que el proporcionado por el tipo int.Clase BigIntegerBigInteger es una clase en Java que permite manejar enteros muy grandes que están fuera del rango de los tipos de datos primitivos como int y long. 
Proporciona métodos para operaciones aritméticas, cálculo de MCD, generación de números primos, manipulación de bits, y más.

------------------------------------------------------------------------------------------------------------------------------------------

Actividad 1.3 

public class SumaRecursiva {
    public static int sumar(int n) {
        // Caso base: si n es 1, la suma es 1
        if (n == 1) {
            return 1;
        } else {
            // Caso recursivo: n + suma de los primeros (n-1) números
            return n + sumar(n - 1);
        }
    }

    public static void main(String[] args) {
        int n = 5; // Puedes cambiar este valor por el que desees
        System.out.println("La suma de los primeros " + n + " números enteros es: " + sumar(n));
    }
}

