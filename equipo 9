clase 1
ejemplo 

public static void main(String[] args) {
    int[][] mat = {
            {4, 5, 6},
            {7, 8, 9},
            {5, 6, 7}
    };

    int suma = 0;
    int n = mat.length; // Suponiendo que la matriz es cuadrada, n será tanto el número de filas como de columnas

    // Sumar todos los elementos de la matriz
    for (int i = 0; i < n; i++) {                  // Instrucción 1
        for (int j = 0; j < n; j++) {              // Instrucción 2
            suma += mat[i][j];                     // Instrucción 3
        }
    }

    // Calcular el número total de elementos
    int totalElementos = n * n;                    // Instrucción 4

    // Calcular el promedio
    double promedio = (double) suma / totalElementos; // Instrucción 5

    // Imprimir el promedio
    System.out.println("El promedio de los elementos de la matriz es: " + promedio); // Instrucción 6
}
------------------------------------------------------------------------------------------------------------------------------------------------

Actividad 1.1
public class MaximoArray {
    public static int encontrarMaximo(int[] array) {
        int max = array[0];
        for (int i = 1; i < array.length; i++) {
            if (array[i] > max) {
                max = array[i];
            }
        }
      return max;
    }
    public static void main(String[] args) {
        int[] numeros = {4, 7, 1, 9, 3};
        int maximo = encontrarMaximo(numeros);
        System.out.println("El Maximo es: " + maximo);
    }
}


/// Orden de complejidad asintótica:
//La complejidad asintótica del programa es ( O(n) ), donde ( n ) es el número de elementos en el array.
// Esto se debe a que el algoritmo debe recorrer todos los elementos del array una vez para encontrar el máximo.


public class FacturaciónSinMap {
    public static void main(String[] args) {
        int[][] facturas = {
                {1, 1, 100},
                {2, 2, 200},
                {3, 1, 150}
        };

        String[][] clientes = {
                {"1", "Cliente1"},
                {"2", "Cliente2"},
        };

        for (String[] cliente : clientes) {
            int idCliente = Integer.parseInt(cliente[0]);
            String nombreCliente = cliente[1];
            int sumaImportes = 0;

            for (int[] factura : facturas) {
                if (factura[1] == idCliente) {
                    sumaImportes += factura[2];
                }
            }

            System.out.println("ID Cliente: " + idCliente + ", Nombre: " + nombreCliente + ", Suma Importes: " + sumaImportes);
        }
    }
}

/// Diferencia en cuanto a la complejidad asintótica:
// Sin Map: La complejidad es ( O(n \times m) ), donde ( n ) es el número de clientes y ( m ) es el número de facturas. Esto se debe a que, para cada cliente, se recorre la lista completa de facturas.
// Con Map: La complejidad es ( O(n + m) ). Primero se recorre la lista de facturas una vez para sumar los importes por cliente (( O(m) )), y luego se recorre la lista de clientes para imprimir los resultados (( O(n) )).
// Esto es más eficiente que la implementación sin Map.


import java.util.HashMap;
import java.util.Map;

public class FacturaciónConMap {
    public static void main(String[] args) {
        int[][] facturas = {
                {1, 1, 100},
                {2, 2, 200},
                {3, 1, 150}
        };

        Map<Integer, String> clientes = new HashMap<>();
        clientes.put(1, "Cliente1");
        clientes.put(2, "Cliente2");

        Map<Integer, Integer> sumaImportesPorCliente = new HashMap<>();

        for (int[] factura : facturas) {
            int idCliente = factura[1];
            int importe = factura[2];

            sumaImportesPorCliente.put(idCliente, sumaImportesPorCliente.getOrDefault(idCliente, 0) + importe);
        }

        for (Map.Entry<Integer, Integer> entrada : sumaImportesPorCliente.entrySet()) {
            int idCliente = entrada.getKey();
            int sumaImportes = entrada.getValue();
            String nombreCliente = clientes.get(idCliente);

            System.out.println("ID Cliente: " + idCliente + ", Nombre: " + nombreCliente + ", Suma Importes: " + sumaImportes);
        }
    }
}

---------------------------------------------------------------------------------------------------------------------

Actividad 1.2



import java.math.BigInteger;

public class LongAndBigIntegerExample {
    public static void main(String[] args) {
        // Example using long
        long a = 9223372036854775807L; // Maximum value of long
        long b = 1L;
        long resultLong = a + b; // This will cause an overflow

        System.out.println("Result using long (with overflow): " + resultLong);

        // Example using BigInteger
        BigInteger bigA = new BigInteger("9223372036854775807");
        BigInteger bigB = new BigInteger("1");
        BigInteger resultBigInteger = bigA.add(bigB); // No overflow here

        System.out.println("Result using BigInteger: " + resultBigInteger);
    }
}

/// Tipo de Dato longEl tipo de dato long en Java es un entero con complemento a dos de 64 bits. 
Tiene un valor mínimo de -2^63 y un valor máximo de 2^63-1. 
Se usa cuando necesitas un rango de valores más amplio que el proporcionado por el tipo int.Clase BigIntegerBigInteger es una clase en Java que permite manejar enteros muy grandes que están fuera del rango de los tipos de datos primitivos como int y long. 
Proporciona métodos para operaciones aritméticas, cálculo de MCD, generación de números primos, manipulación de bits, y más.

------------------------------------------------------------------------------------------------------------------------------------------

Actividad 1.3 

public class SumaRecursiva {
    public static int sumar(int n) {
        // Caso base: si n es 1, la suma es 1
        if (n == 1) {
            return 1;
        } else {
            // Caso recursivo: n + suma de los primeros (n-1) números
            return n + sumar(n - 1);
        }
    }

    public static void main(String[] args) {
        int n = 5; // Puedes cambiar este valor por el que desees
        System.out.println("La suma de los primeros " + n + " números enteros es: " + sumar(n));
    }
}

------------------------------------------------------------------------------------------------------------------------------------------

Clase 2

Actividad 1

public static int getHeight(TreeNode root) {
        if(root==null) { 
            return -1;
        } else {
            return 1+ Math.max(getHeight(root.left),getHeight(root.right));
        }    
    }

    public static void main(String[] args) {

        // Crear un árbol de ejemplo
        TreeNode root = new TreeNode(10);
        root.left = new TreeNode(5);
        root.right = new TreeNode(20);
        root.left.left = new TreeNode(3);
        root.left.right = new TreeNode(7);
        root.right.left = new TreeNode(15);
        root.right.right = new TreeNode(25);
        root.right.right.right = new TreeNode(30);

        
        System.out.println("Altura del arbol es " + getHeight(root));

    }
-------------------------------------------------------------------------------------------------------------------------------------------

Actividad 2

public static int busquedaBinaria(int[] arreglo, int objetivo) {
        int izquierda = 0;
        int derecha = arreglo.length - 1;

        while (izquierda <= derecha) {
            int medio = izquierda + (derecha - izquierda) / 2;

            // Verificar si el objetivo está en el medio
            if (arreglo[medio] == objetivo) {
                return medio; // Retorna el índice del objetivo
            }

            // Si el objetivo es mayor, ignorar la mitad izquierda
            if (arreglo[medio] < objetivo) {
                izquierda = medio + 1;
            } 
            // Si el objetivo es menor, ignorar la mitad derecha
            else {
                derecha = medio - 1;
            }
        }

        // Si no se encuentra el objetivo, retorna -1
        return -1;
    }
public static void main(String[] args) {
    int[] arreglo = {1, 3, 5, 7, 9, 11, 13};
    int objetivo = 7;
    int resultado = busquedaBinaria(arreglo, objetivo);

    if (resultado == -1) {
        System.out.println("Elemento no encontrado en el arreglo.");
    } else {
        System.out.println("Elemento encontrado en el índice: " + resultado);
    }
}
--------------------------------------------------------------------------------------------------------------------------------------------------
Actividad 3
public class main {
    public static void main(String[] args) {
        int[] arreglo = {34, 7, 23, 32, 5, 62};

        System.out.println("Arreglo desordenado:");
        imprimirArreglo(arreglo);

        QuickSort.quickSort(arreglo, 0, arreglo.length - 1);

        System.out.println("Arreglo ordenado:");
        imprimirArreglo(arreglo);
    }

    public static void imprimirArreglo(int[] arreglo) {
        for (int i : arreglo) {
            System.out.print(i + " ");
        }
        System.out.println();
    }
}

public class QuickSort {
    public static void quickSort(int[] arreglo, int bajo, int alto) {
        if (bajo < alto) {
            int indiceParticion = particion(arreglo, bajo, alto);
            quickSort(arreglo, bajo, indiceParticion - 1);
            quickSort(arreglo, indiceParticion + 1, alto);
        }
    }

   


private static int particion(int[] arreglo, int bajo, int alto) {
        int pivote = arreglo[alto];
        int i = (bajo - 1);

        for (int j = bajo; j < alto; j++) {
            if (arreglo[j] <= pivote) {
                i++;
                int temp = arreglo[i];
                arreglo[i] = arreglo[j];
                arreglo[j] = temp;
            }
        }

        int temp = arreglo[i + 1];
        arreglo[i + 1] = arreglo[alto];
        arreglo[alto] = temp;

        return i + 1;
    }
}
----------------------------------------------------------------------------------------------------------------------------------------------------
Actividad 4
public class MergeSort {

    // Método principal que ordena el arreglo
    public static void mergeSort(int[] arreglo) {
        // Si el arreglo tiene 0 o 1 elementos, ya está ordenado
        if (arreglo.length < 2) {
            return;
        }

        // Encontrar el punto medio del arreglo
        int medio = arreglo.length / 2;

        // Crear subarreglos para las dos mitades
        int[] izquierda = new int[medio];
        int[] derecha = new int[arreglo.length - medio];

        // Copiar los elementos a las mitades
        for (int i = 0; i < medio; i++) {
            izquierda[i] = arreglo[i];
        }
        for (int i = medio; i < arreglo.length; i++) {
            derecha[i - medio] = arreglo[i];
        }

        // Llamadas recursivas para ordenar las mitades
        mergeSort(izquierda);
        mergeSort(derecha);

        // Mezclar las mitades ordenadas
        merge(arreglo, izquierda, derecha);
    }

    // Método para mezclar dos mitades ordenadas
    private static void merge(int[] arreglo, int[] izquierda, int[] derecha) {
        int i = 0, j = 0, k = 0;

        // Mezclar los elementos de los subarreglos en orden
        while (i < izquierda.length && j < derecha.length) {
            if (izquierda[i] <= derecha[j]) {
                arreglo[k++] = izquierda[i++];
            } else {
                arreglo[k++] = derecha[j++];
            }
        }

        // Copiar los elementos restantes de la mitad izquierda, si hay
        while (i < izquierda.length) {
            arreglo[k++] = izquierda[i++];
        }

        // Copiar los elementos restantes de la mitad derecha, si hay
        while (j < derecha.length) {
            arreglo[k++] = derecha[j++];
        }
    }

    // Método principal para probar el algoritmo
    public static void main(String[] args) {
        int[] arreglo = {38, 27, 43, 3, 9, 82, 10};
        mergeSort(arreglo);
        System.out.println("Arreglo ordenado:");
        for (int num : arreglo) {
            System.out.print(num + " ");
        }
    }
}
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Clase 3
Actividad 1

class Cliente {
    int id;
    String nombre;
    int scoring;

    Cliente(int id, String nombre, int scoring) {
        this.id = id;
        this.nombre = nombre;
        this.scoring = scoring;
    }
}

public class MaximoScoring {

    public static Cliente encontrarMaximoScoring(Cliente[] listaClientes, int inicio, int fin) {
        if (inicio == fin) {
            return listaClientes[inicio];
        }

        int medio = (inicio + fin) / 2;
        Cliente maxIzquierda = encontrarMaximoScoring(listaClientes, inicio, medio);
        Cliente maxDerecha = encontrarMaximoScoring(listaClientes, medio + 1, fin);

        return (maxIzquierda.scoring >= maxDerecha.scoring) ? maxIzquierda : maxDerecha;
    }

    public static void main(String[] args) {
        Cliente[] listaClientes = {
            new Cliente(1, "Cliente A", 85),
            new Cliente(2, "Cliente B", 92),
            new Cliente(3, "Cliente C", 76),
            new Cliente(4, "Cliente D", 99),
            new Cliente(5, "Cliente E", 65)
        };

        Cliente maxCliente = encontrarMaximoScoring(listaClientes, 0, listaClientes.length - 1);
        System.out.println("Cliente con el scoring máximo: " + maxCliente.nombre + " con un scoring de " + maxCliente.scoring);
    }
}
---------------------------------------------------------------------------------------------------------------------------------------------------------
Actividad 2

